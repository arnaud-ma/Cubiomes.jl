var documenterSearchIndex = {"docs":
[{"location":"api/MCVersions/#Minecraft-Versions","page":"MCVersions","title":"Minecraft Versions","text":"","category":"section"},{"location":"api/MCVersions/","page":"MCVersions","title":"MCVersions","text":"Cubiomes.MCVersions","category":"page"},{"location":"api/MCVersions/#Cubiomes.MCVersions","page":"MCVersions","title":"Cubiomes.MCVersions","text":"MCVersions\n\nRepresentation of Minecraft versions in Julia. Works like the built in VersionNumber type but for Minecraft versions, with the mcv\"\" string macro and the MCVersion abstract type.\n\n\n\n\n\n","category":"module"},{"location":"api/MCVersions/#Index","page":"MCVersions","title":"Index","text":"","category":"section"},{"location":"api/MCVersions/","page":"MCVersions","title":"MCVersions","text":"Modules = [Cubiomes.MCVersions]","category":"page"},{"location":"api/MCVersions/#API","page":"MCVersions","title":"API","text":"","category":"section"},{"location":"api/MCVersions/","page":"MCVersions","title":"MCVersions","text":"Modules = [Cubiomes.MCVersions]\nOrder =  [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api/MCVersions/#Cubiomes.MCVersions.MCVersion","page":"MCVersions","title":"Cubiomes.MCVersions.MCVersion","text":"MCVersion\n\nThe parent type of every Minecraft version.\n\n\n\n\n\n","category":"type"},{"location":"api/MCVersions/#Cubiomes.MCVersions.@mcv_str-Tuple{Any}","page":"MCVersions","title":"Cubiomes.MCVersions.@mcv_str","text":"@mcv_str\n\nA string macro to get a Minecraft version. For example mcv\"1.8.9\" represents the 1.8.9 version or mcv\"beta1.7\" for the beta 1.7.\n\n!!!warning     It does not exactly represents a Minecraft version, but more a close one, where the     biome generation is the same. For example, mcv\"1.8.6\" is exactly equal to mcv\"1.8.9     since the generation does not change between those two versions.\n\n\n\n\n\n","category":"macro"},{"location":"api/MCVersions/#Cubiomes.MCVersions.@mcvt_str-Tuple{Any}","page":"MCVersions","title":"Cubiomes.MCVersions.@mcvt_str","text":"@mcvt_str\n\nA string macro to get the type representation of one or more (with an Union{}) Minecraft versions. Useful for functions who need to dispatch over specifics versions.\n\nThe syntax is:     - mcvt\"1.8.9\" -> expands to Type{mcv\"1.8.9\"}     - mcvt\">=1.8.9\" -> expands to Union{...} on every version >=1.8.9.       The supported operations are <, <=, >, >=.     - mcvt\"1.0.0<=x<=1.8.9 -> expands to Union{...} on every version such that 1.0.0<=version<=1.8.9.       The place holder x can be anything, can even be empty. The supported operations are only <, <=.\n\nExample\n\n``` julia> endtype(::mcvt\"<1.0.0\") = nothing endtype (generic function with 3 methods)\n\njulia> endtype(::mcvt\"1.0.0<=<1.9.0\") = :old end_type (generic function with 3 methods)\n\njulia> endtype(::mcvt\">=1.9.0\") = :new endtype (generic function with 3 methods)\n\njulia> end_type(mcv\"1.13\") :new\n\n\n\n\n\n","category":"macro"},{"location":"api/MCVersions/#Private-API","page":"MCVersions","title":"Private API","text":"","category":"section"},{"location":"api/MCVersions/","page":"MCVersions","title":"MCVersions","text":"Modules = [Cubiomes.MCVersions]\nOrder =  [:constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api/Noises/#Noises","page":"Noises","title":"Noises","text":"","category":"section"},{"location":"api/Noises/","page":"Noises","title":"Noises","text":"Cubiomes.Noises","category":"page"},{"location":"api/Noises/#Cubiomes.Noises","page":"Noises","title":"Cubiomes.Noises","text":"note: Note\nWorking over raw noise functions is very low-level and should only be used as a last resort or for performance reasons.\n\nNoises is a module to generate and sample various types of noise functions used in the procedural generation of Minecraft worlds. The result are always floating, but the input can be any type of number.\n\nA noise object can be quite big in memory, so we can create an undefined noise object and initialize it without copying it with the set_rng!🎲 function, saving time and memory.\n\nThe main uses are with the functions:\n\nNoise : create an undefined noise object.\nset_rng!🎲 : initialize the noise object.\nNoise🎲 : create and initialize the noise object in one step.\nsample_noise : sample the noise at a given point.\n\nThe noises implemented are:\n\nPerlin : a Perlin noise.\nOctaves : a sum of N Perlin noises.\nDoublePerlin : a sum of two independent and identically distributed Octaves noises.\n\n\n\n\n\n","category":"module"},{"location":"api/Noises/#Index","page":"Noises","title":"Index","text":"","category":"section"},{"location":"api/Noises/","page":"Noises","title":"Noises","text":"Modules = [Cubiomes.Noises]","category":"page"},{"location":"api/Noises/#API","page":"Noises","title":"API","text":"","category":"section"},{"location":"api/Noises/","page":"Noises","title":"Noises","text":"Modules = [Cubiomes.Noises]\nOrder =  [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api/Noises/#Cubiomes.Noises.DoublePerlin","page":"Noises","title":"Cubiomes.Noises.DoublePerlin","text":"DoublePerlin{N} <: Noise\n\nA double Perlin noise implementation. It's a sum of two independent and identically distributed (iid) Octaves{N} noise.\n\n\n\n\n\n","category":"type"},{"location":"api/Noises/#Cubiomes.Noises.Noise","page":"Noises","title":"Cubiomes.Noises.Noise","text":"Noise\n\nThe abstract type for a Noise sampler.\n\nMethods\n\nsample_noise\nset_rng!🎲\nNoise(::Type{Noise}, ::UndefInitializer, ...)\nNoise🎲\nis_undef\n\nSee also:  Perlin, Octaves, DoublePerlin\n\n\n\n\n\n","category":"type"},{"location":"api/Noises/#Cubiomes.Noises.Noise-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, UndefInitializer, Vararg{Any, N}}} where {T<:Cubiomes.Noises.Noise, N}","page":"Noises","title":"Cubiomes.Noises.Noise","text":"Noise(::Type{T}, ::UndefInitializer) where {T<:Noise}\nNoise(::Type{DoublePerlin}; ::UndefInitializer, amplitudes)\n\nCreate a noise of type T with an undefined state, i.e., it is not initialized yet. Use set_rng!🎲 or unsafe_set_rng!🎲 to initialize it.\n\nSee also: Noise🎲, set_rng!🎲, unsafe_set_rng!🎲\n\n\n\n\n\n","category":"method"},{"location":"api/Noises/#Cubiomes.Noises.Octaves","page":"Noises","title":"Cubiomes.Noises.Octaves","text":"Octaves{N} <: Noise\n\nAn ordered collection of N Perlin objects representing the octaves of a noise.\n\nSee also: Noise, [sample_noise], Perlin, DoublePerlin\n\n\n\n\n\n","category":"type"},{"location":"api/Noises/#Cubiomes.Noises.Perlin","page":"Noises","title":"Cubiomes.Noises.Perlin","text":"Perlin <: Noise\n\nThe type for the perlin noise. See https://en.wikipedia.org/Perlin_Noise to know how it works.\n\nSee also: Noise, sample_noise, sample_simplex\n\n\n\n\n\n","category":"type"},{"location":"api/Noises/#Cubiomes.Noises.Noise🎲-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Cubiomes.JavaRNG.AbstractJavaRNG, Vararg{Any, N}}} where {T<:Cubiomes.Noises.Noise, N}","page":"Noises","title":"Cubiomes.Noises.Noise🎲","text":"Noise🎲(::Type{T}, rng::AbstractJavaRNG, args...) where {N, T<:Noise}\n\nCreate a noise of type T and initialize it with the given random number generator rng. Other arguments are used to initialize the noise. They depend on the noise type and they are the same as the arguments of the set_rng!🎲 function.\n\nStrictly equivalent to\n\njulia> noise = Noise(T, undef) # or Noise(T, undef, args[1]) for DoublePerlin\nT(...)\n\njulia> set_rng!🎲(noise, rng, args...)`.\n\nSee also: Noise, set_rng!🎲\n\n\n\n\n\n","category":"method"},{"location":"api/Noises/#Cubiomes.Noises.is_undef","page":"Noises","title":"Cubiomes.Noises.is_undef","text":"is_undef(noise::Noise)\n\nCheck if the noise is undefined, i.e., it has not been initialized yet.\n\n\n\n\n\n","category":"function"},{"location":"api/Noises/#Cubiomes.Noises.sample_noise","page":"Noises","title":"Cubiomes.Noises.sample_noise","text":"sample_noise(noise::Perlin, x, z, y=missing, yamp=0, ymin=0)\nsample_noise(noise::Octaves, x, z, y=missing, yamp=missing, ymin=missing)\nsample_noise(noise::DoublePerlin, x, z, y=missing, [move_factor,])\n\nSample the given noise at the specified coordinates.\n\nSee also: sample_simplex, Noise, Noise🎲\n\n\n\n\n\n","category":"function"},{"location":"api/Noises/#Cubiomes.Noises.sample_simplex","page":"Noises","title":"Cubiomes.Noises.sample_simplex","text":"sample_simplex(noise::Perlin, x, y)\n\nSample the given noise at the given coordinate using the simplex noise algorithm instead of the perlin one. See https://en.wikipedia.org/wiki/Simplex_noise\n\nSee also: sample_noise, Perlin\n\n\n\n\n\n","category":"function"},{"location":"api/Noises/#Cubiomes.Noises.set_rng!🎲","page":"Noises","title":"Cubiomes.Noises.set_rng!🎲","text":"set_rng!🎲(noise::Perlin, rng)\nset_rng!🎲(noise::Octaves{N}, rng::JavaRandom, octave_min) where N\nset_rng!🎲(noise::Octaves{N}, rng::JavaXoroshiro128PlusPlus, amplitudes, octave_min) where N\nset_rng!🎲(noise::DoublePerlin{N}, rng, octave_min) where N\nset_rng!🎲(noise::DoublePerlin{N}, rng, amplitudes, octave_min) where N\n\n` Initialize the noise in place with the given random number generator (of type AbstractJavaRNG).\n\nwarning: Warning\nN represents the number of octaves, each associated with a non-zero amplitude. Therefore, N MUST be equal to the number of non-zero values in amplitudes. This number can be obtained with Cubiomes.length_filter(!iszero, amplitudes). For performance reasons, it is possible to lower N and completely ignore the last amplitudes using unsafe_set_rng!🎲.\n\ntip: Tip\nSince the last amplitudes are ignored if they are set to zero, replace the tuple of amplitudes with the trimmed version without the last zeros can save a very small amount of memory / time. However, only do this if the trimmed amplitudes are already known. Computing them only for this function call will not save any time.\n\nSee also: unsafe_set_rng!🎲, Noise, Noise🎲\n\n\n\n\n\n","category":"function"},{"location":"api/Noises/#Cubiomes.Noises.unsafe_set_rng!🎲","page":"Noises","title":"Cubiomes.Noises.unsafe_set_rng!🎲","text":"unsafe_set_rng!🎲(noise, rng::JavaXoroshiro128PlusPlus, amplitudes, octave_min)\n\nSame as set_rng!🎲 but allows to skip some octaves for performance reasons, i.e. N can be less than the number of non-zero values in amplitudes, and the last octaves are completely ignored. If instead N is greater, the behavior is undefined.\n\nSee also: set_rng!🎲, Noise, Noise🎲\n\n\n\n\n\n","category":"function"},{"location":"api/Noises/#Private-API","page":"Noises","title":"Private API","text":"","category":"section"},{"location":"api/Noises/","page":"Noises","title":"Noises","text":"Modules = [Cubiomes.Noises]\nOrder =  [:constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api/Noises/#Cubiomes.Noises.indexed_lerp-Tuple{Integer, Any, Any, Any}","page":"Noises","title":"Cubiomes.Noises.indexed_lerp","text":"indexed_lerp(idx::Integer, x, y, z)\n\nUse the lower 4 bits of idx as a simple hash to combine the x, y, and z values into a single number (a new index), to be used in the Perlin noise interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/Noises/#Cubiomes.Noises.init_coord_values-Tuple{Any}","page":"Noises","title":"Cubiomes.Noises.init_coord_values","text":"init_coord_values(coord)\n\nInitialize one coordinate for the Perlin noise sampling.\n\nReturns:\n\nthe fractional part of coord\nthe integer part of coord, modulo UInt8\nthe smoothstep value of the fractional part of coord\n\nSee also: smoothstep_perlin_unsafe, sample_noise, Perlin\n\n\n\n\n\n","category":"method"},{"location":"api/Noises/#Cubiomes.Noises.interpolate_perlin-Tuple{OffsetArrays.OffsetVector{UInt8, StaticArraysCore.MVector{257, UInt8}}, Vararg{Any, 9}}","page":"Noises","title":"Cubiomes.Noises.interpolate_perlin","text":"interpolate_perlin(\n            idx::PermsType,\n            d1, d2, d3,\n            h1, h2, h3,\n            t1, t2, t3\n        ) -> Real\n\nInterpolate the Perlin noise at the given coordinates.\n\nArguments\n\nThe idx parameter is the permutations array.\nThe d1, d2, and d3 parameters are the fractional parts of the x, y, and z\n\ncoordinates.\n\nThe h1, h2, and h3 parameters are the integer parts of the x, y, and z\n\ncoordinates. They MUST be between 0 and 255.\n\nThe t1, t2, and t3 parameters are the smoothstep values of the fractional parts\n\nof the x, y, and z coordinates.\n\nSee also: init_coord_values, sample_noise, Perlin\n\n\n\n\n\n","category":"method"},{"location":"api/Noises/#Cubiomes.Noises.next_perlin🎲","page":"Noises","title":"Cubiomes.Noises.next_perlin🎲","text":"next_perlin🎲(rng::JavaRandom, ::Type{Int32}; start=0, stop) -> Int32\nnext_perlin🎲(rng::JavaXoroshiro128PlusPlus, ::Type{Int32}; start=0, stop) -> Int3\n\nSame as next🎲 but with a different implementation specific for the perlin noise. Don't ask why this is different, it's just how Minecraft does it.\n\nSee also: next🎲\n\n\n\n\n\n","category":"function"},{"location":"api/Noises/#Cubiomes.Noises.shuffle!🎲-Tuple{Cubiomes.JavaRNG.AbstractJavaRNG, OffsetArrays.OffsetVector{UInt8, StaticArraysCore.MVector{257, UInt8}}}","page":"Noises","title":"Cubiomes.Noises.shuffle!🎲","text":"shuffle!🎲(rng::AbstractRNG_MC, perms::PermsType)\n\nShuffle the permutations array using the given random number generator.\n\n\n\n\n\n","category":"method"},{"location":"api/Noises/#Cubiomes.Noises.simplex_gradient-NTuple{5, Any}","page":"Noises","title":"Cubiomes.Noises.simplex_gradient","text":"simplex_gradient(idx, x, y, z, d)\n\nCompute the gradient of the simplex noise at the given coordinates.\n\nArguments\n\nidx: Index used for interpolation.\nx, y, z: Coordinates in the simplex grid.\nd: Constant used to determine the influence of the point in the grid.\n\nSee also: sample_simplex\n\n\n\n\n\n","category":"method"},{"location":"api/Noises/#Cubiomes.Noises.smoothstep_perlin_unsafe-Tuple{Any}","page":"Noises","title":"Cubiomes.Noises.smoothstep_perlin_unsafe","text":"smoothstep_perlin_unsafe(x)\n\nCompute 6x^5 - 15x^4 + 10x^3, the smoothstep function used in Perlin noise. See https://en.wikipedia.org/wiki/Smoothstep#Variations for more details.\n\nThis function is unsafe because it is assuming that 0 <= x <= 1 (it does not clamp the input).\n\n\n\n\n\n","category":"method"},{"location":"api/JavaRNG/#JavaRNG","page":"JavaRNG","title":"JavaRNG","text":"","category":"section"},{"location":"api/JavaRNG/","page":"JavaRNG","title":"JavaRNG","text":"Cubiomes.JavaRNG","category":"page"},{"location":"api/JavaRNG/#Cubiomes.JavaRNG","page":"JavaRNG","title":"Cubiomes.JavaRNG","text":"A module that mimics the behavior of Java's random number generators in Julia. Only the functionalities needed by the Minecraft Java Edition are implemented.\n\nThe rngs implemented are:\n\nJavaRandom for the java.util.Random class.\nJavaXoroshiro128PlusPlus for the Xoroshiro128PlusPlus PRNG.\n\nOnly the [next🎲] function is used to get random numbers. Instead of nextDouble or nextInt in Java, use next🎲(rng, Float64) or next🎲(rng, Int32) respectively.\n\n\n\n\n\n","category":"module"},{"location":"api/JavaRNG/#Index","page":"JavaRNG","title":"Index","text":"","category":"section"},{"location":"api/JavaRNG/","page":"JavaRNG","title":"JavaRNG","text":"Modules = [Cubiomes.JavaRNG]","category":"page"},{"location":"api/JavaRNG/#API","page":"JavaRNG","title":"API","text":"","category":"section"},{"location":"api/JavaRNG/","page":"JavaRNG","title":"JavaRNG","text":"Modules = [Cubiomes.JavaRNG]\nOrder =  [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api/JavaRNG/#Cubiomes.JavaRNG.JavaRandom","page":"JavaRNG","title":"Cubiomes.JavaRNG.JavaRandom","text":"JavaRandom(seed::Integer)\n\nA pseudorandom number generator that mimics the behavior of Java's java.util.Random class.\n\nExamples\n\njulia> rng = JavaRandom(1234);\nJavaRandom(0x00000005deece2bf)\n\njulia> next_int32_range!(rng, 10)\n3\n\n\n\n\n\n","category":"type"},{"location":"api/JavaRNG/#Cubiomes.JavaRNG.JavaXoroshiro128PlusPlus","page":"JavaRNG","title":"Cubiomes.JavaRNG.JavaXoroshiro128PlusPlus","text":"JavaXoroshiro128PlusPlus(lo::UInt64, hi::UInt64)\nJavaXoroshiro128PlusPlus(seed::Integer)\n\nA pseudo-random number generator that mimics the behavior of Java's implementation of Xoroshiro128PlusPlus PRNG.\n\n\n\n\n\n","category":"type"},{"location":"api/JavaRNG/#Cubiomes.JavaRNG.next🎲-Union{Tuple{T}, Tuple{T, Any}} where T<:Cubiomes.JavaRNG.AbstractJavaRNG","page":"JavaRNG","title":"Cubiomes.JavaRNG.next🎲","text":"next🎲(rng::AbstractJavaRNG, ::Type{T}) where T\nnext🎲(rng::AbstractJavaRNG, ::Type{T}, stop) where T\nnext🎲(rng::AbstractJavaRNG, ::Type{T}, start, stop) where T\n\nGenerate a random number of type T from the given random number generator. If start and stop are provided, the random number will be in the range [start, stop]. start is default to 0.\n\n\n\n\n\n","category":"method"},{"location":"api/JavaRNG/#Cubiomes.JavaRNG.randjump🎲-Union{Tuple{T}, Tuple{T, Any, Integer}} where T<:Cubiomes.JavaRNG.AbstractJavaRNG","page":"JavaRNG","title":"Cubiomes.JavaRNG.randjump🎲","text":"randjump🎲(rng::AbstractJavaRNG, ::Type{T}, n::Integer) where T\n\nJump the state of the random number generator n steps forward, without generating any random numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/JavaRNG/#Cubiomes.JavaRNG.set_seed🎲-Tuple{Cubiomes.JavaRNG.AbstractJavaRNG, Any, Vararg{Any}}","page":"JavaRNG","title":"Cubiomes.JavaRNG.set_seed🎲","text":"set_seed🎲(rng::AbstractJavaRNG, seed) -> AbstractJavaRNG\n\nInitialize the rng with the given seed. Return the rng itself for convenience.\n\n\n\n\n\n","category":"method"},{"location":"api/JavaRNG/#Private-API","page":"JavaRNG","title":"Private API","text":"","category":"section"},{"location":"api/JavaRNG/","page":"JavaRNG","title":"JavaRNG","text":"Modules = [Cubiomes.JavaRNG]\nOrder =  [:constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"home/#Cubiomes.jl","page":"Home","title":"Cubiomes.jl","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Cubiomes.jl is a Julia port of the Cubiomes C library. It allows for fast and efficient imitation of Minecraft's world structure and biome generation. Compared to the original C library, Cubiomes.jl is both faster and significantly easier to use, thanks to Julia.","category":"page"},{"location":"home/#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Find a mushroom fields biome at a predefined location:","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"using Cubiomes\nusing Base.Iterators: countfrom\n\nfunction search_biome_at(x, z, y)\n    overworld = Overworld(undef, mcv\"1.18\")\n\n    for seed in countfrom(zero(UInt64))\n        set_seed!(overworld, seed)\n        biome = get_biome(overworld, x, z, y)\n\n        if biome == Biomes.mushroom_fields\n            println(\"Seed $(signed(seed)) has a Mushroom Fields at $((x, z, y))\")\n            break\n        end\n    end\nend\n\nsearch_biome_at(0, 0, 63)","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Generate a map of biomes and save it as an image:","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"using Cubiomes\nusing FileIO\n\nconst overworld1_18 = Overworld(undef, mcv\"1.18\")\nconst worldmap = WorldMap(x=-1000:1000, z=-1000:1000, y=63)\n\nfunction save_as_img!(worldmap, seed, path)\n    set_seed!(overworld1_18, seed)\n    gen_biomes!(overworld1_18, worldmap, 📏\"1:16\")\n\n    world2d = view2d(worldmap)\n    save(path, to_color(world2d))\nend\n\nsave_as_img!(worldmap, 42, \"world.png\")","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"The image world.png: (Image: world.png)","category":"page"},{"location":"guide2/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide2/#Minecraft-versions","page":"Guide","title":"Minecraft versions","text":"","category":"section"},{"location":"guide2/","page":"Guide","title":"Guide","text":"To get a Minecraft version, simply use the mcv keyword (stands for Minecraft version). For example:","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"julia> mcv\"1.18\"\nmcv\"1.18.2\"","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"Note that it is returned mcv\"1.18.2\". This is because Cubiomes.jl only focuses on the latest minor version, and so mcv\"1.18\" is exactly the same as mcv\"1.18.2. Generally, everything remains the same between minor versions. But to be safe, be sure to verify that the version is the same as the one you are looking for.","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"Comparing versions is possible. But the main uses of the versions is to link them to dimensions.","category":"page"},{"location":"guide2/#Dimension-objects","page":"Guide","title":"Dimension objects","text":"","category":"section"},{"location":"guide2/","page":"Guide","title":"Guide","text":"In a lot of cases, you need to specify a dimension to work with. The three dimensions are:","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"Overworld\nNether\nEnd","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"They all are subtypes of the abstract type Dimension. A dimension object is always associated with a Minecraft version.","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"julia> overworld = Overworld(undef, mcv\"1.18\")\nCubiomes.BiomeGeneration.BiomeNoise{mcv\"1.18.2\"}(...)","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"As suggests the undef argument, the object is \"empty\" and completely usless. A Minecraft seed must be set to the object before using it:","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"julia> set_seed!(overworld, 42)","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"The seed can be any valid Minecraft seed, i.e. a string or an integer. But if performance is a concern, it is better to use an integer.","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"The \"!\" at the end of the function name is a Julia convention to indicate that the function modifies the object inplace. In this case, it modifies the overworld object to set the seed. It allows to avoid creating a new object each time the seed is set, keeping the same overworld object for every seed we want to use, and thus saving time and memory.","category":"page"},{"location":"guide2/#Biome-generation","page":"Guide","title":"Biome generation","text":"","category":"section"},{"location":"guide2/","page":"Guide","title":"Guide","text":"We now have three informations combined in a single Dimension object:","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"A dimension\nA Minecraft version\nA seed","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"To get the biome at a specific location, use the get_biome function:","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"julia> get_biome(overworld, 0, 0, 63)\ndark_forest::Biome = 0x1d\n\njulia> get_biome(overworld, (0, 0, 63))  # different syntax\ndark_forest::Biome = 0x1d","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"warning: Warning\nIn Cubiomes.jl, the order of the coordinates is ALWAYS (x, z, y). This is different from the order used in Minecraft, which is (x, y, z).","category":"page"},{"location":"guide2/#Biome-generation-on-a-WorldMap","page":"Guide","title":"Biome generation on a WorldMap","text":"","category":"section"},{"location":"guide2/","page":"Guide","title":"Guide","text":"To generate a map of biomes, we can think about creating a matrix or a 3D array and using get_biome for each block. But Cubiomes.jl provides a more easy and efficient way to do this: the WorldMap object combined with the gen_biomes! function.","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"julia> worldmap = WorldMap(x=-100:100, z=-100:100, y=63)\n2001×2001×1 OffsetArray(::Array{Biome, 3}, -1000:1000, -1000:1000, 63:63) with eltype Biome with indices -1000:1000×-1000:1000×63:63:\n[:, :, 63] =\n BIOME_NONE::Biome = 0xff ...\n\njulia> gen_biomes!(overworld, worldmap)\n2001×2001×1 OffsetArray(::Array{Biome, 3}, -1000:1000, -1000:1000, 63:63) with eltype Biome with indices -1000:1000×-1000:1000×63:63:\n[:, :, 63] =\n beach::Biome = 0x10 ...\n\njulia> worldmap[0, 0, 63] # get the biome at the location (0, 0, 63)\ndark_forest::Biome = 0x1d","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"The WorldMap object is an alias for any 3D / 2D array (depending if y is passed or not). The indices of the array are the real coordinates of the world. The gen_biomes! function fills the array with the biomes. For some versions / dimensions, gen_biomes! can be much faster than calling get_biome for each block, because it has a global view of the world, and can use this information to optimize the biome generation.","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"Same as for the Dimension object, the \"!\" at the end of the function name indicates that the function modifies the world map inplace. So no need to create a new world map each time you want to generate the biomes where a parameter is different (except for the map size of course).","category":"page"},{"location":"guide2/#The-Scale-object","page":"Guide","title":"The Scale object","text":"","category":"section"},{"location":"guide2/","page":"Guide","title":"Guide","text":"In get_biome and gen_biomes!, there is a last optional argument: the Scale object. If the world is a 2d map, the world is divided into regions of scale×scale blocks, and the coordinates are the coordinates of this region NOT the coordinates of the block. For example, a scale of 4 corresponds to the chunk coordinates in Minecraft.","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"A scale can be constructed with 📏\"1:N\" or Scale(N) if you don't like emojis. the scale MUST be a power of 4. So the first ones are:","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"📏\"1:1\" the block scale\n📏\"1:4\" the chunk scale\n📏\"1:16\", 📏\"1:64\", 📏\"1:256\", 📏\"1:1024\", ...","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"In some versions / dimensions, it can be much faster than simply rescaling the coordinates before calling get_biome or gen_biomes!, because the original Minecraft biome generation divides the world into regions multiple times until the scale is 1.","category":"page"},{"location":"guide2/","page":"Guide","title":"Guide","text":"julia>","category":"page"},{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"If you are already familiar with Julia, you can skip this section and go directly to the guide.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"To install Julia and learn how to run Julia code, refer to the Getting Started section of the Julia documentation.","category":"page"},{"location":"gettingstarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"To install Cubiomes.jl, start up Julia and enter the following command in the REPL:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"julia> ] add github.com/arnaud-ma/Cubiomes.jl","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Then, you can import Cubiomes.jl into the namespace","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"julia> using Cubiomes","category":"page"},{"location":"gettingstarted/#Getting-help","page":"Getting Started","title":"Getting help","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"To get help on specific functionality you can either look up the information here, or you can use the built-in help system in Julia. For example, to get help on the get_biome function:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"julia>?\n\nhelp?> get_biome\nsearch: get_biome gen_biomes!\n\n  get_biome(dim::Dimension, x::Real, z::Real, y::Real, [scale::Scale,], args...; kwargs...) -> Biome\n  get_biome(dim::Dimension, coord, [scale::Scale,], args...; kwargs...) -> Biome\n\n  Get the biome at the coordinates (x, z, y) in the dimension dim. The coordinates can be passed as numbers or as ...","category":"page"},{"location":"api/BiomeGeneration/#BiomeGeneration","page":"BiomeGeneration","title":"BiomeGeneration","text":"","category":"section"},{"location":"api/BiomeGeneration/","page":"BiomeGeneration","title":"BiomeGeneration","text":"Cubiomes.BiomeGeneration","category":"page"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration","text":"BiomeGeneration\n\nModule for generating biomes in Minecraft worlds.\n\nwarning: Warning\nLike almost everything in this package, the coordinates order is always(x, z, y), not (x, y, z) weither it is for function calls, world indexing, etc. If it is too confusing, hide the order by working directly over the coordinate objects, or use keyword arguments.\n\nThe typical workflow is:\n\nCreate a dimension object (e.g. Overworld, Nether, End) -> Dimension\nSet the seed of the dimension -> set_seed!\nGet the biome at a specific coordinate -> get_biome\n\nOr:\n\nCreate a world object -> WorldMap\nGenerate the biomes in the world -> gen_biomes!\n\nThe biomes are stored in a WorldMap object, which is a 3D array of biomes. To get the coordinates of the biomes, use the coordinates function. It gives an iterator of CartesianIndex objects, a built-in Julia type. So any intuitive indexing should work out of the box.\n\n\n\n\n\n","category":"module"},{"location":"api/BiomeGeneration/#Index","page":"BiomeGeneration","title":"Index","text":"","category":"section"},{"location":"api/BiomeGeneration/","page":"BiomeGeneration","title":"BiomeGeneration","text":"Modules = [Cubiomes.BiomeGeneration]","category":"page"},{"location":"api/BiomeGeneration/#API","page":"BiomeGeneration","title":"API","text":"","category":"section"},{"location":"api/BiomeGeneration/","page":"BiomeGeneration","title":"BiomeGeneration","text":"Modules = [Cubiomes.BiomeGeneration, Cubiomes.BiomeGeneration.Voronoi, Cubiomes.BiomeGeneration.BiomeArrays]\nOrder =  [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.Dimension","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.Dimension","text":"Dimension\n\nThe parent type of every Minecraft dimension. There is generally three steps to use a dimension:\n\nCreate one dimension with a specific MCVersion and maybe some specific arguments.\nSet the seed of the dimension with set_seed!.\nDo whatever you want with the dimension: get biomes, generate biomes, etc.\n\nExamples\n\njulia> overworld = Overworld(undef, mcv\"1.18\");\n\njulia> set_seed!(overworld, 42)\n\njulia> get_biome(overworld, 0, 0, 63)\ndark_forest::Biome = 0x1d\n\njulia> set_seed!(overworld, \"I love cats\")\n\njulia> world = WorldMap(x=-100:100, z=-100:100, y=63);\n\njulia> gen_biomes!(overworld, world, scale=📏\"1:4\")\n\nSee also:\n\nNether, Overworld, End\nset_seed!, get_biome, gen_biomes!\nWorldMap, Scale\n\nExtended help\n\nThis section is for developers that want to implement a new dimension.\n\nThe concrete type TheDim MUST implement:\n\nAn uninitialized constructor TheDim(::UndefInitializer, ::MCVersion, args...)\nAn inplace constructor set_seed!(dim::TheDim, seed::UInt64, args...). Be aware that the seed must be constrained to UInt64 dispatch to work.\nget_biome(dim::TheDim, coord, scale::Scale, args...) -> Biome where coord can be either (x::Real, z::Real, y::Real) or NTuple{3}\ngen_biomes!(dim::TheDim, out::WorldMap, scale::Scale, args...)\n\n\n\n\n\n","category":"type"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.End","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.End","text":"End(::UndefInitializer, version::MCVersion)\n\nThe Minecraft End dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.Nether","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.Nether","text":"Nether(::UndefInitializer, V::MCVersion)\n\nThe Nether dimension. See Dimension for general usage.\n\nMinecraft version <1.16\n\nBefore version 1.16, the Nether is only composed of nether wastes. Nothing else.\n\nMinecraft version >= 1.16 specificities\n\nIf the 1:1 scale will never be used, adding sha=Val(false) to set_seed! will save a very small amount of time (of the order of 100ns up to 1µs). The sha is a precomputed value only used for the 1:1 scale. But the default behavior is to compute the sha at each seed change for simplicity.\nIn the biome generation functions, a last paramter confidence can be passed. It is a performance-related parameter between 0 and 1. A bit the same as the scale parameter, but it is a continuous value, and the scale is not modified.\n\n\n\n\n\n","category":"type"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.Overworld","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.Overworld","text":"Overworld(::UndefInitializer, ::mcvt\">=1.18\")\n\nThe Overworld dimension. See Dimension for general usage.\n\nwarning: Warning\nAt the moment, only version 1.18 and above are supported. Older versions will be supported in the future.\n\nMinecraft version >= 1.18 specificities\n\nIf the 1:1 scale will never be used, adding sha=Val(false) to set_seed! will save a very small amount of time (of the order of 100ns up to 1µs). The sha is a precomputed value only used for the 1:1 scale. But the default behavior is to compute the sha at each seed change for simplicity.\nTwo keyword arguments are added to the biome generation:\nskip_depth=Val(false): if Val(true), the depth sampling is skipped. Time saved: 1/3 of the biome generation time.\nskip_shift=Val(false): only for the 1:1 and 1:4 scales. If Val(true), the shift sampling is skipped. Time saved: 1/10 of the biome generation time.\n\n\n\n\n\n","category":"type"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.Scale","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.Scale","text":"Scale{N}\nScale(N::Integer)\n📏\"1:N\"\n\nThe scale of a map. It represents the ratio between the size of the map an the real world. For example, a 1:4 scale map means that each block in the map represents a 4x4 area in the real world. So the coordinates (5, 5) are equal to the real world coordinates (20, 20).\n\nN MUST ne to the form 4^n n geq 0. So the more common scales are 1:1, 1:4, 1:16, 1:64, 1:256. The support for big scales is not guaranteed and depends on the function that uses it. Read the documentation of the function that uses it to know the supported values.\n\nIt is possible to use the alternative syntax 📏\"1:N\". The emoji name is :straight_ruler:.\n\nExamples\n\njulia> Scale(4)\nScale{4}()\n\njulia> Scale(5)\nERROR: ArgumentError: The scale must be to the form 4^n. Got 1:5. The closest valid scales are 1:4 and 1:16.\n\njulia> 📏\"1:4\" === Scale(4) === Scale{4}()\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.gen_biomes!-Tuple{Dimension, AbstractArray{Biome}}","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.gen_biomes!","text":"gen_biomes!(dim::Dimension, world::WorldMap, [scale::Scale,], args...; kwargs...) -> Nothing\n\nFill the world map with the biomes of the dimension dim. The scale is defaulted to 1:1. The args are specific to the dimension. See the documentation of the dimension for more information.\n\nSee also: WorldMap, Scale, Dimension, get_biome\n\n\n\n\n\n","category":"method"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.get_biome","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.get_biome","text":"get_biome(dim::Dimension, x::Real, z::Real, y::Real, [scale::Scale,], args...; kwargs...) -> Biome\nget_biome(dim::Dimension, coord, [scale::Scale,], args...; kwargs...) -> Biome\n\nGet the biome at the coordinates (x, z, y) in the dimension dim. The coordinates can be passed as numbers or as tuples or as CartesianIndex (the coords returned by coordinates). The scale is defaulted to 1:1 (the more precise).\n\nThe scale is defaulted to 1:1, i.e. the exact coordinates. The args are specific to the dimension. See the documentation of the dimension for more information.\n\nSee also:     - Scale, gen_biomes!, Dimension\n\n\n\n\n\n","category":"function"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.set_seed!-Tuple{Dimension, Any}","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.set_seed!","text":"set_seed!(dim::Dimension, seed; kwargs...)\n\nSet the seed of the dimension generator. It can be any valid seed you can pass like in Minecraft, but UInt64 is better if performance is a concern. To transform an UInt64 seed to a \"normal\" one, use signed(seed).\n\nOther keyword arguments can be passed, specific to the dimension / minecraft version. They are often related to some micro-optimizations. See the documentation of the specific dimension for more information.\n\nSee also: Nether, Overworld, End\n\n\n\n\n\n","category":"method"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.BiomeArrays.WorldMap-Union{NTuple{N, UnitRange}, Tuple{N}} where N","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.BiomeArrays.WorldMap","text":"WorldMap{N} where N (N = 2, 3)\nWorldMap(xrange::UnitRange, zrange::UnitRange, yrange::UnitRange)\nWorldMap(xrange::UnitRange, zrange::UnitRange, y::Number)\nWorldMap(xrange::UnitRange, zrange::UnitRange)\nWorldMap(;x, z, y)\n\nA 2D or 3D array of biomes. It is the main data structure used to store the biomes of a Minecraft world. It is a simple wrapper around AbstractArray{Biome, N}. So anything that works with arrays should work with WorldMap.\n\nSee also: view2d, coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.BiomeArrays.coordinates-Tuple{AbstractArray{Biome}}","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.BiomeArrays.coordinates","text":"coordinates(M::WorldMap) -> CartesianIndices\n\nWrapper around CartesianIndices to get the coordinates of the biomes in the map. Useful to iterate over the coordinates of the map.\n\n\n\n\n\n","category":"method"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.BiomeArrays.view2d-Tuple{AbstractArray{Biome, 3}}","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.BiomeArrays.view2d","text":"view2d(W::WorldMap{3}) -> WorldMap{2}\n\nView a 3D world as a 2D world. Only works if the y size is 1. Otherwise, it throws an error. Useful for functions that only work with 2D worlds, even if the y size is 1, like 2d visualization.\n\nwarning: Warning\nThe returned object is a view, so modifying it will also modify the original world. Use copy to get a new independent world.\n\n\n\n\n\n","category":"method"},{"location":"api/BiomeGeneration/#Private-API","page":"BiomeGeneration","title":"Private API","text":"","category":"section"},{"location":"api/BiomeGeneration/","page":"BiomeGeneration","title":"BiomeGeneration","text":"Modules = [Cubiomes.BiomeGeneration, Cubiomes.BiomeGeneration.Voronoi, Cubiomes.BiomeGeneration.BiomeArrays]\nOrder =  [:constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.SomeSha","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.SomeSha","text":"SomeSha\n\nA struct that holds a UInt64 or nothing. It is used to store the SHA of the seed if it is needed. Acts like a reference (a zero dimension array) to a UInt64 or nothing. Use sha[] to get or store the value, or directly set_seed!(sha, seed) to compute the SHA of the seed and store it and reset!(sha) to set it to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.fill_radius!-Union{Tuple{N}, Tuple{AbstractArray{Biome, N}, CartesianIndex{2}, Biome, Any}} where N","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.fill_radius!","text":"fill_radius!(out::WorldMap{N}, center::CartesianIndex{2}, id::Biome, radius)\n\nFills a circular area around the point center in out with the biome id, within a given radius. Assuming radius>=0. If center is outside the out coordinates, nothing is done.\n\n\n\n\n\n","category":"method"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.original_get_biome-Tuple{Cubiomes.BiomeGeneration.End1_9Plus, Any, Any, Scale{4}}","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.original_get_biome","text":"original_get_biome(end_noise::EndNoise, x, z)\n\nOriginal algorithm to get the biome at a given point in the End dimension. It is only here for documentation purposes, because everything else is just optimizations and scaling on this basis (for scale >= 4).\n\nBut not so sure that the optimizations are really important, most of ones are just avoid √ operations, but hypot is already really fast in Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.similar_expand-Union{Tuple{T}, Tuple{Type{T}, OffsetArrays.OffsetMatrix{T} where T, Int64, Int64}} where T","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.similar_expand","text":"similar_expand{T}(mc_map::OffsetMatrix, expand_x::Int, expand_z::Int) where T\n\nCreate an uninitialized OffsetMatrix of type T but with additional rows and columns on each side of the original matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.view_reshape_cache_like","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.view_reshape_cache_like","text":"view_reshape_cache_like(axes)\n\nCreate a view of the cache with the same shape as the axes.\n\nwarning: Warning\nThis function is not thread-safe and should not be used in a multithreaded context.\n\nThis is a TODO: maybe use of @init from Floops.jl to create a thread-safe cache\n\n\n\n\n\n","category":"function"},{"location":"api/BiomeGeneration/#Cubiomes.BiomeGeneration.Voronoi.voronoi_access-Union{Tuple{T}, Tuple{UInt64, Tuple{T, T, T}}} where T","page":"BiomeGeneration","title":"Cubiomes.BiomeGeneration.Voronoi.voronoi_access","text":"voronoi_access(sha::UInt64, coord::Union{CartesianIndex{3}, NTuple{3, T}}) where {T}\nvoronoi_access(sha::UInt64, x, z, y)\n\nCompute the closest Voronoi cell based on the given coordinates (at 1:4 scale). Used by Minecraft to translate the 1:4 scale coordinates to the 1:1 scale.\n\nFor example we can find in some part of the biome generation source code:\n\n>>> function get_biome(dimension, x, z, y, ::Scale{1})\n        sx, sz, zy = voronoi_access(dimension, x, z, y)\n        get_biome(dimension, sx, sz, sy, Scale(4))\n    end\n\n\n\n\n\n","category":"method"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"EditURL = \"../literate/guide.jl\"","category":"page"},{"location":"literate_generated/guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"This guide covers 90% of use cases.","category":"page"},{"location":"literate_generated/guide/#Table-of-contents","page":"Guide","title":"Table of contents","text":"","category":"section"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"Minecraft version\nDimension object\nBiome generation\nBiome generation on a world map","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"First of all, do not forget to import Cubiomes","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"using Cubiomes\nusing ImageShow # hide","category":"page"},{"location":"literate_generated/guide/#Minecraft-versions","page":"Guide","title":"Minecraft versions","text":"","category":"section"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"To get a Minecraft version, simply use the mcv keyword (short for Minecraft version).","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"mcv\"1.18\"","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"Note that the returned value is mcv\"1.18.2\". This is because Cubiomes.jl focuses only on the latest minor version of Minecraft, meaning mcv\"1.18\" is exactly the same as mcv\"1.18.2\". Generally, everything remains the same between minor versions. But to be safe, ensure that the version matches the one you need.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"Comparing versions is possible","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"mcv\"beta1.7\" < mcv\"1.8\"","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"However, the main purpose of versions is to link them to a dimension.","category":"page"},{"location":"literate_generated/guide/#Dimension-objects","page":"Guide","title":"Dimension objects","text":"","category":"section"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"Before generating anything, we often need to get a specific dimension to work with. The three dimensions are:","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"Overworld\nNether\nEnd","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"They are all subtypes of Dimension. To create a new dimension, link it to a version.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"overworld = Overworld(undef, mcv\"1.18\")","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"As suggested by the undef keyword, the object is currently uninitialized and unusable. We need to assign it a seed.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"set_seed!(overworld, 999)\noverworld","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"The seed can be any valid Minecraft seed, i.e., a string or an integer. However, for performance reasons, integers are preferred.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"The \"!\" at the end of set_seed! follows Julia’s convention, indicating that the function modifies the object (overworld) in place. This prevents the creation of a new object each time a seed is set, allowing reuse of the same overworld instance. The only constant requirement in a dimension is its version.","category":"page"},{"location":"literate_generated/guide/#Biome-generation","page":"Guide","title":"Biome generation","text":"","category":"section"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"We now have three key pieces of information combined in a single Dimension object:","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"the dimension\nthe version\nthe seed","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"Now, we just need to call the get_biome function, providing our object and a coordinate.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"get_biome(overworld, -55, 45, 63)","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"The coordinates can be passed as three numbers or as a tuple (x, z, y):","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"coord = (-55, 45, 63)\nget_biome(overworld, coord)","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"warning: Warning\nIn Cubiomes.jl, the coordinate order is ALWAYS (x, z, y). This differs from Minecraft’s order, which is (x, y, z).","category":"page"},{"location":"literate_generated/guide/#Biome-generation-on-a-world-map","page":"Guide","title":"Biome generation on a world map","text":"","category":"section"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"Let's generate an empty map with x and z ranging from -200 to 200, and y = 63.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"worldmap = WorldMap(-200:200, -200:200, 63)","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"Note that this is a 3D array, even if the size of y is 1. The y size can be greater than 1 as well. Some useful utility functions:","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"coordinates: returns a collection of coordinates instead of biomes.\nview2d: provides a 2D view by removing the y axis when its size is 1. Useful for visualization so that Julia recognizes it as 2D. ⚠ This is a view, meaning modifying one also modifies the other. Use copy to create an independent map.\nto_color: creates a new map with colors representing biomes (e.g., green for forests).","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"To visualize our map:","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"to_color(worldmap)","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"note: Note\nIf you see a bunch of numbers instead of an image, nothing is wrong. The colors are just not displayed in your environment. You can either:Use a Jupyter notebook\nSave the image using FileIO: using FileIO; save(\"worldmap.png\", to_color(worldmap))","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"The map is currently empty. To populate it with biomes from our overworld object:","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"for coord in coordinates(worldmap)\n    worldmap[coord] = get_biome(overworld, coord)\nend\nto_color(worldmap)","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"And it works! However, it is inefficient. Because of how Minecraft generation works, we can optimize the process by leveraging a global world view. For certain dimensions/versions, this can be significantly faster. That's what gen_biomes! is for.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"gen_biomes!(overworld, worldmap)\nto_color(worldmap)","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"A world map acts like a standard array; the only difference is that its indices correspond to Minecraft coordinates.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"worldmap[-55, 45]","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"try # hide\nworldmap[-155, 45]\ncatch err ;showerror(stderr, err) end # hide","category":"page"},{"location":"literate_generated/guide/#The-scale-object","page":"Guide","title":"The scale object","text":"","category":"section"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"In get_biome and gen_biomes!, there is an optional final argument: the Scale object. A scale can be created using 📏\"1:N\", where N is a power of 4.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"worldmap2 = WorldMap(-50:50, -50:50, 16)\ngen_biomes!(overworld, worldmap2, 📏\"1:4\")\nto_color(worldmap2)","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"The scale determines the size of square/cube regions where only one block from each region is \"sampled\" and displayed as one pixel. A larger scale results in a more zoomed-out map.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"⚠ When using a scale, the indices no longer match Minecraft coordinates. Instead, for example, with scale 📏\"1:4\", they correspond to chunk coordinates.","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"The first scales are:","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"📏\"1:1\" — Block scale\n📏\"1:4\" — Chunk scale\n📏\"1:16\", 📏\"1:64\", 📏\"1:256\", 📏\"1:1024\", ..., 📏\"1:4^k\" for any integer k","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"In some versions and dimensions, this approach is much faster than simply dividing the coordinates by the scale, since Minecraft's biome generation algorithm inherently divides the world into regions multiple times until reaching scale 📏\"1:1\".","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"","category":"page"},{"location":"literate_generated/guide/","page":"Guide","title":"Guide","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/Biomes/#Biomes","page":"Biomes","title":"Biomes","text":"","category":"section"},{"location":"api/Biomes/","page":"Biomes","title":"Biomes","text":"Cubiomes.Biomes","category":"page"},{"location":"api/Biomes/#Cubiomes.Biomes","page":"Biomes","title":"Cubiomes.Biomes","text":"Biomes\n\nMinecraft biome constants and functions to work with them / compare them.\n\n\n\n\n\n","category":"module"},{"location":"api/Biomes/","page":"Biomes","title":"Biomes","text":"The list of all biome names (Biomes.biome_name):","category":"page"},{"location":"api/Biomes/","page":"Biomes","title":"Biomes","text":"ocean\nplains\ndesert\nmountains\nforest\ntaiga\nswamp\nriver\nnether_wastes\nthe_end\nfrozen_ocean\nfrozen_river\nsnowy_tundra\nsnowy_mountains\nmushroom_fields\nmushroom_field_shore\nbeach\ndesert_hills\nwooded_hills\ntaiga_hills\nmountain_edge\njungle\njungle_hills\njungle_edge\ndeep_ocean\nstone_shore\nsnowy_beach\nbirch_forest\nbirch_forest_hills\ndark_forest\nsnowy_taiga\nsnowy_taiga_hills\ngiant_tree_taiga\ngiant_tree_taiga_hills\nwooded_mountains\nsavanna\nsavanna_plateau\nbadlands\nwooded_badlands_plateau\nbadlands_plateau\nsmall_end_islands\nend_midlands\nend_highlands\nend_barrens\nwarm_ocean\nlukewarm_ocean\ncold_ocean\ndeep_warm_ocean\ndeep_lukewarm_ocean\ndeep_cold_ocean\ndeep_frozen_ocean\nseasonal_forest\nrainforest\nshrubland\nthe_void\nsunflower_plains\ndesert_lakes\ngravelly_mountains\nflower_forest\ntaiga_mountains\nswamp_hills\nice_spikes\nmodified_jungle\nmodified_jungle_edge\ntall_birch_forest\ntall_birch_hills\ndark_forest_hills\nsnowy_taiga_mountains\ngiant_spruce_taiga\ngiant_spruce_taiga_hills\nmodified_gravelly_mountains\nshattered_savanna\nshattered_savanna_plateau\neroded_badlands\nmodified_wooded_badlands_plateau\nmodified_badlands_plateau\nbamboo_jungle\nbamboo_jungle_hills\nsoul_sand_valley\ncrimson_forest\nwarped_forest\nbasalt_deltas\ndripstone_caves\nlush_caves\nmeadow\ngrove\nsnowy_slopes\njagged_peaks\nfrozen_peaks\nstony_peaks\nold_growth_birch_forest\nold_growth_pine_taiga\nold_growth_spruce_taiga\nsnowy_plains\nsparse_jungle\nstony_shore\nwindswept_hills\nwindswept_forest\nwindswept_gravelly_hills\nwindswept_savanna\nwooded_badlands\ndeep_dark\nmangrove_swamp\ncherry_grove","category":"page"},{"location":"api/Biomes/","page":"Biomes","title":"Biomes","text":"And a special BIOME_NONE.","category":"page"},{"location":"api/Biomes/#Index","page":"Biomes","title":"Index","text":"","category":"section"},{"location":"api/Biomes/","page":"Biomes","title":"Biomes","text":"Modules = [Cubiomes.Biomes]","category":"page"},{"location":"api/Biomes/#API","page":"Biomes","title":"API","text":"","category":"section"},{"location":"api/Biomes/","page":"Biomes","title":"Biomes","text":"Modules = [Cubiomes.Biomes]\nOrder =  [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api/Biomes/#Cubiomes.Biomes.are_similar-Tuple{MCVersion, Biome, Biome}","page":"Biomes","title":"Cubiomes.Biomes.are_similar","text":"are_similar(version::MCVersion, biome1::Biome, biome2::Biome)\n\nFor a given version, check if two biomes have the same category. wooded_badlands_plateau and badlands_plateau are considered similar even though they have a different category in version <= 1.15.\n\n\n\n\n\n","category":"method"},{"location":"api/Biomes/#Cubiomes.Biomes.biome_exists-Tuple{Biome, Union{Cubiomes.MCVersions.v1_20, Cubiomes.MCVersions.v1_21}}","page":"Biomes","title":"Cubiomes.Biomes.biome_exists","text":"biome_exists(biome::Biome, version::MCVersion)\n\nReturn true if the given biome exists in the given version and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/Biomes/#Cubiomes.Biomes.category-Tuple{Biome, MCVersion}","page":"Biomes","title":"Cubiomes.Biomes.category","text":"category(biome::Biome, version::MCVersion)\n\nReturn the category of the given biome in the given version. The categories are:\n\nbeach\ndesert\nmountains\nforest\nsnowy_tundra\njungle\nmesa\nmushroom_fields\nstone_shore\nocean\nplains\nriver\nsavanna\nswamp\ntaiga\nnether_wastes\n\nIf the biome does not belong to any of these categories, return BIOME_NONE.\n\n\n\n\n\n","category":"method"},{"location":"api/Biomes/#Cubiomes.Biomes.is_overworld-Tuple{Biome, MCVersion}","page":"Biomes","title":"Cubiomes.Biomes.is_overworld","text":"is_overworld(biome::Biome, version::MCVersion)\n\nReturn true if the given biome is an overworld biome and false otherwise. If the biome does not exist in the given version, return false.\n\nExamples\n\njulia> is_overworld(Biomes.ocean, mcv\"1.16\",)\ntrue\n\njulia> [biome for biome in instances(Biome) if is_overworld(biome, mcv\"1.16\")]\n90-element Vector{Biome}:\n ocean::Biome = 0x00\n plains::Biome = 0x01\n desert::Biome = 0x02\n ...\n\n\n\n\n\n\n","category":"method"},{"location":"api/Biomes/#Cubiomes.Biomes.mutated-Tuple{Biome, MCVersion}","page":"Biomes","title":"Cubiomes.Biomes.mutated","text":"mutated(biome::Biome, version::MCVersion)\n\nReturn the mutated variant of the given biome in the given version. If the biome does not have a mutated variant, return BIOME_NONE.\n\n\n\n\n\n","category":"method"},{"location":"api/Biomes/#Private-API","page":"Biomes","title":"Private API","text":"","category":"section"},{"location":"api/Biomes/","page":"Biomes","title":"Biomes","text":"Modules = [Cubiomes.Biomes]\nOrder =  [:constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api/Display/#Display","page":"Display","title":"Display","text":"","category":"section"},{"location":"api/Display/","page":"Display","title":"Display","text":"Cubiomes.Display","category":"page"},{"location":"api/Display/#Cubiomes.Display","page":"Display","title":"Cubiomes.Display","text":"Display\n\nModule for visualization of results\n\n\n\n\n\n","category":"module"},{"location":"api/Display/#Index","page":"Display","title":"Index","text":"","category":"section"},{"location":"api/Display/","page":"Display","title":"Display","text":"Modules = [Cubiomes.Display]","category":"page"},{"location":"api/Display/#API","page":"Display","title":"API","text":"","category":"section"},{"location":"api/Display/","page":"Display","title":"Display","text":"Modules = [Cubiomes.Display]\nOrder =  [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api/Display/#Cubiomes.Display.to_color-Tuple{Biome}","page":"Display","title":"Cubiomes.Display.to_color","text":"to_color(b::Biome)\nto_color(w::WorldMap)\n\nReturn a color / an array of colors corresponding to a biome. It should only be used for visualization, since two biomes can have the same color.\n\n\n\n\n\n","category":"method"},{"location":"api/Display/#Private-API","page":"Display","title":"Private API","text":"","category":"section"},{"location":"api/Display/","page":"Display","title":"Display","text":"Modules = [Cubiomes.Display]\nOrder =  [:constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api/SeedUtils/#SeedUtils","page":"SeedUtils","title":"SeedUtils","text":"","category":"section"},{"location":"api/SeedUtils/","page":"SeedUtils","title":"SeedUtils","text":"Cubiomes.SeedUtils","category":"page"},{"location":"api/SeedUtils/#Cubiomes.SeedUtils","page":"SeedUtils","title":"Cubiomes.SeedUtils","text":"Minecraft Seed Utilities, like the LCG algorithm used in the seed generation.\n\n\n\n\n\n","category":"module"},{"location":"api/SeedUtils/#Index","page":"SeedUtils","title":"Index","text":"","category":"section"},{"location":"api/SeedUtils/","page":"SeedUtils","title":"SeedUtils","text":"Modules = [Cubiomes.SeedUtils]","category":"page"},{"location":"api/SeedUtils/#API","page":"SeedUtils","title":"API","text":"","category":"section"},{"location":"api/SeedUtils/","page":"SeedUtils","title":"SeedUtils","text":"Modules = [Cubiomes.SeedUtils]\nOrder =  [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api/SeedUtils/#Private-API","page":"SeedUtils","title":"Private API","text":"","category":"section"},{"location":"api/SeedUtils/","page":"SeedUtils","title":"SeedUtils","text":"Modules = [Cubiomes.SeedUtils]\nOrder =  [:constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api/SeedUtils/#Cubiomes.SeedUtils.MAGIC_LCG_INCREMENTOR","page":"SeedUtils","title":"Cubiomes.SeedUtils.MAGIC_LCG_INCREMENTOR","text":"MAGIC_LCG_INCREMENTOR::UInt64\n\nThe incrementor used in the LCG algorithm. This is a constant used in the Minecraft seed generation algorithm.\n\nSee Also: MAGIC_LCG_MULTIPLIER, mc_step_seed, LCG wiki\n\n\n\n\n\n","category":"constant"},{"location":"api/SeedUtils/#Cubiomes.SeedUtils.MAGIC_LCG_MULTIPLIER","page":"SeedUtils","title":"Cubiomes.SeedUtils.MAGIC_LCG_MULTIPLIER","text":"MAGIC_LCG_MULTIPLIER::UInt64\n\nThe multiplier used in the LCG algorithm. This is a constant used in the Minecraft seed generation algorithm.\n\nSee Also: MAGIC_LCG_INCREMENTOR, mc_step_seed, LCG wiki\n\n\n\n\n\n","category":"constant"},{"location":"api/SeedUtils/#Cubiomes.SeedUtils.mc_step_seed-Tuple{Any, Any}","page":"SeedUtils","title":"Cubiomes.SeedUtils.mc_step_seed","text":"mc_step_seed(seed::UInt64, salt::UInt64)\n\nUsed to generate the next seed in the Minecraft seed generation algorithm, given the current seed and a salt.\n\n\n\n\n\n","category":"method"},{"location":"api/Utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api/Utils/","page":"Utils","title":"Utils","text":"Cubiomes.Utils","category":"page"},{"location":"api/Utils/#Cubiomes.Utils","page":"Utils","title":"Cubiomes.Utils","text":"Some utility functions and types that are used in various places in the codebase. It should not be used directly by the user and could be nice if this module does not exist at all.\n\n\n\n\n\n","category":"module"},{"location":"api/Utils/#Index","page":"Utils","title":"Index","text":"","category":"section"},{"location":"api/Utils/","page":"Utils","title":"Utils","text":"Modules = [Cubiomes.Utils]","category":"page"},{"location":"api/Utils/#API","page":"Utils","title":"API","text":"","category":"section"},{"location":"api/Utils/","page":"Utils","title":"Utils","text":"Modules = [Cubiomes.Utils]\nOrder =  [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api/Utils/#Private-API","page":"Utils","title":"Private API","text":"","category":"section"},{"location":"api/Utils/","page":"Utils","title":"Utils","text":"Modules = [Cubiomes.Utils]\nOrder =  [:constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api/Utils/#Cubiomes.Utils.bytes2uint64-Tuple{Any}","page":"Utils","title":"Cubiomes.Utils.bytes2uint64","text":"bytes2uint64(itr)\n\nConverts an iterator of bytes to an iterator of UInt64.\n\nExample\n\n>>> bytes2uint64([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10]) |> collect\n2-element Vector{UInt64}:\n0x0102030405060708\n0x090a0b0c0d0e0f10\n\n\n\n\n\n","category":"method"},{"location":"api/Utils/#Cubiomes.Utils.findfirst_default-Tuple{Function, Any, Any}","page":"Utils","title":"Cubiomes.Utils.findfirst_default","text":"findfirst_default(predicate::Function, A, default)\n\nReturn the first index i of A where predicate(A[i]) is true. If no i satisfy this, default is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"api/Utils/#Cubiomes.Utils.length_of_trimmed-Tuple{Any, Any}","page":"Utils","title":"Cubiomes.Utils.length_of_trimmed","text":"length_of_trimmed(predicate, x) where N\n\nReturns the length of the collection x after removing the elements from the beginning and the end that satisfy the predicate.\n\n⚠ The collection must have the property so that x[i] for i in firstindex(x):lastindex(x) is valid.\n\n\n\n\n\n","category":"method"},{"location":"api/Utils/#Cubiomes.Utils.u64_seed","page":"Utils","title":"Cubiomes.Utils.u64_seed","text":"u64_seed(x)\n\nConverts x to UInt64 for use as a seed, exactly as the Minecraft Java Edition does. It can be any integer or a string.\n\nExample\n\njulia> u64_seed(1234)\n0x00000000000004d2\n\njulia> u64_seed(\"hello world\")\n0x000000006aefe2c4\n\n\n\n\n\n","category":"function"},{"location":"api/Utils/#Cubiomes.Utils.@map_inline-Tuple{Any, Any}","page":"Utils","title":"Cubiomes.Utils.@map_inline","text":"@map_inline(func, tuple)\n\nInline the loop done by map(func, tuple), i.e. transform it to the tuple of the form (:func(x1), :func(x2), ...) at compile-time. Improves performance for small tuples.\n\n\n\n\n\n","category":"macro"},{"location":"api/Utils/#Cubiomes.Utils.@only_float32-Tuple{Any}","page":"Utils","title":"Cubiomes.Utils.@only_float32","text":"@only_float32 expr\n\nTransforms all real literals in the expr to Float32.\n\nExample\n\n@only_float32 function f()\n    x = 1 + 2im # expand to `1.0f0 + 2.0f0im`\n    x += 1 # expand to `x += 1.0f0`\n    return x\nend\n\n\n\n\n\n","category":"macro"},{"location":"api/MCBugs/#MCBugs","page":"MCBugs","title":"MCBugs","text":"","category":"section"},{"location":"api/MCBugs/","page":"MCBugs","title":"MCBugs","text":"Cubiomes.MCBugs","category":"page"},{"location":"api/MCBugs/#Cubiomes.MCBugs","page":"MCBugs","title":"Cubiomes.MCBugs","text":"Utility functions for working with known Minecraft bugs.\n\n\n\n\n\n","category":"module"},{"location":"api/MCBugs/#Index","page":"MCBugs","title":"Index","text":"","category":"section"},{"location":"api/MCBugs/","page":"MCBugs","title":"MCBugs","text":"Modules = [Cubiomes.MCBugs]","category":"page"},{"location":"api/MCBugs/#API","page":"MCBugs","title":"API","text":"","category":"section"},{"location":"api/MCBugs/","page":"MCBugs","title":"MCBugs","text":"Modules = [Cubiomes.MCBugs]\nOrder =  [:constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api/MCBugs/#Private-API","page":"MCBugs","title":"Private API","text":"","category":"section"},{"location":"api/MCBugs/","page":"MCBugs","title":"MCBugs","text":"Modules = [Cubiomes.MCBugs]\nOrder =  [:constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api/MCBugs/#Cubiomes.MCBugs.has_bug_mc159283-Tuple{Any, Int64, Int64}","page":"MCBugs","title":"Cubiomes.MCBugs.has_bug_mc159283","text":"has_bug_mc159283(version::MCVersion, x::Int64, z::Int64)\n\nSee MC-159283 for more information.\n\n\n\n\n\n","category":"method"},{"location":"api/MCBugs/#Cubiomes.MCBugs.overflow_int32-Tuple{Int64}","page":"MCBugs","title":"Cubiomes.MCBugs.overflow_int32","text":"overflow_int32(x::Int64)\n\nReturns true if the value x overflows when converted to a signed 32-bit integer.\n\n\n\n\n\n","category":"method"}]
}
